package JAVARuntime;

   import java.util.HashSet;   //[I-S]LN=7;[I-E]
   import java.util.HashMap;   //[I-S]LN=8;[I-E]
   import java.util.Map;   //[I-S]LN=9;[I-E]
   import java.util.Set;   //[I-S]LN=10;[I-E]
import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.*;
import java.util.concurrent.locks.*;
import java.util.function.*;
import java.util.regex.*;
import java.util.stream.*;
import java.util.zip.*;
import java.text.*;
import java.net.*;
import java.math.*;
import java.io.*;
import java.nio.*;
import java.time.*;
import java.time.chrono.*;
import java.time.format.*;
import java.time.temporal.*;
import java.time.zone.*;



public class _JContainer{}

//C-R:DeformMain
class DeformMain extends Component {
      //[I-S]LN=0;[I-E]
      //[I-S]LN=1;[I-E]
      //[I-S]LN=2;[I-E]
   /* @Author Sr Mil Games */   //[I-S]LN=3;[I-E]
      //[I-S]LN=4;[I-E]
   // Code Made by VitorG and Huge Helped by Gpt   //[I-S]LN=5;[I-E]
      //[I-S]LN=6;[I-E]
      //[I-S]LN=11;[I-E]
   // ================================   //[I-S]LN=12;[I-E]
   // Sistema de edição e configuração visual no editor   //[I-S]LN=13;[I-E]
   // ================================   //[I-S]LN=14;[I-E]
   @Order(idx = {0})   //[I-S]LN=15;[I-E]
   boolean Editor_Mode;   //[I-S]LN=16;[I-E]
      //[I-S]LN=17;[I-E]
   @Order(idx = {1})   //[I-S]LN=18;[I-E]
   boolean Editor_Clear_All;   //[I-S]LN=19;[I-E]
      //[I-S]LN=20;[I-E]
   @Order(idx = {2})   //[I-S]LN=21;[I-E]
   boolean Update_Mesh;   //[I-S]LN=22;[I-E]
      //[I-S]LN=23;[I-E]
   @Order(idx = {3})   //[I-S]LN=24;[I-E]
   private int atualizado;   //[I-S]LN=25;[I-E]
      //[I-S]LN=26;[I-E]
   @Order(idx = {4})   //[I-S]LN=27;[I-E]
   boolean Enable_Visible_Points;   //[I-S]LN=28;[I-E]
      //[I-S]LN=29;[I-E]
   @Order(idx = {5})   //[I-S]LN=30;[I-E]
   private boolean lastEVisiblePoints = false;   //[I-S]LN=31;[I-E]
      //[I-S]LN=32;[I-E]
   @Order(idx = {6})   //[I-S]LN=33;[I-E]
   private float[] tempVerts;   //[I-S]LN=34;[I-E]
      //[I-S]LN=35;[I-E]
   @Order(idx = {7})   //[I-S]LN=36;[I-E]
   float Bending_Constraints_Stiff = 0.8f;   //[I-S]LN=37;[I-E]
      //[I-S]LN=38;[I-E]
   @Order(idx = {8})   //[I-S]LN=39;[I-E]
   float Edge_Constraints_Stiff = 0.8f;   //[I-S]LN=40;[I-E]
      //[I-S]LN=41;[I-E]
   @Order(idx = {9})   //[I-S]LN=42;[I-E]
   boolean Reset_Points_Positions = false;    //[I-S]LN=43;[I-E]
   // ================================   //[I-S]LN=44;[I-E]
   // Stiffness e controles diversos   //[I-S]LN=45;[I-E]
   // ================================   //[I-S]LN=46;[I-E]
   @Order(idx = {10})   //[I-S]LN=47;[I-E]
   float Stiffness=0.6f;   //[I-S]LN=48;[I-E]
      //[I-S]LN=49;[I-E]
   @Order(idx = {11})   //[I-S]LN=50;[I-E]
   public float Velocity_Damping = 0.985f; // 0.95..0.995 (maior = mais fluido)   //[I-S]LN=51;[I-E]
      //[I-S]LN=52;[I-E]
   @Order(idx = {12})   //[I-S]LN=53;[I-E]
   boolean Do_Not_Use_Phys;   //[I-S]LN=54;[I-E]
      //[I-S]LN=55;[I-E]
   // ================================   //[I-S]LN=56;[I-E]
   // Colisores externos (adicionados manualmente na cena)   //[I-S]LN=57;[I-E]
   // ================================   //[I-S]LN=58;[I-E]
          //[I-S]LN=59;[I-E]
   @Order(idx = {13}) //[I-S]LN=60;[I-E]
   public float pointRadius = 0.02f; // ajuste conforme escala da malha //[I-S]LN=61;[I-E]
    //[I-S]LN=62;[I-E]
   @Order(idx = {20})   //[I-S]LN=63;[I-E]
   public List<SpatialObject> Colliders_Mesh = new ArrayList<SpatialObject>();   //[I-S]LN=64;[I-E]
      //[I-S]LN=65;[I-E]
   @Order(idx = {21})   //[I-S]LN=66;[I-E]
   public List<SpatialObject> Colliders_Box = new ArrayList<SpatialObject>();   //[I-S]LN=67;[I-E]
      //[I-S]LN=68;[I-E]
   @Order(idx = {22})   //[I-S]LN=69;[I-E]
   public List<SpatialObject> Colliders_Sphere = new ArrayList<SpatialObject>();   //[I-S]LN=70;[I-E]
   // ================================   //[I-S]LN=71;[I-E]
   // Parâmetros de vento   //[I-S]LN=72;[I-E]
   // ================================   //[I-S]LN=73;[I-E]
   @Order(idx = {30})   //[I-S]LN=74;[I-E]
   public Vector3 Wind_Global_Direction = new Vector3(1, 0, 0).normalize();   //[I-S]LN=75;[I-E]
      //[I-S]LN=76;[I-E]
   @Order(idx = {31})   //[I-S]LN=77;[I-E]
   public float Wind_Strength = 50.0f;   //[I-S]LN=78;[I-E]
      //[I-S]LN=79;[I-E]
   @Order(idx = {32})   //[I-S]LN=80;[I-E]
   public float Turbulence = 1.5f;   //[I-S]LN=81;[I-E]
      //[I-S]LN=82;[I-E]
   @Order(idx = {33})   //[I-S]LN=83;[I-E]
   public float Pressure_Coefficient = 0.15f;   //[I-S]LN=84;[I-E]
      //[I-S]LN=85;[I-E]
   @Order(idx = {34})   //[I-S]LN=86;[I-E]
   public float Wind_Noise_Scale = 0.1f;   //[I-S]LN=87;[I-E]
      //[I-S]LN=88;[I-E]
   @Order(idx = {35})   //[I-S]LN=89;[I-E]
   public float Wind_Frequency = 0.3f;   //[I-S]LN=90;[I-E]
      //[I-S]LN=91;[I-E]
   @Order(idx = {36})   //[I-S]LN=92;[I-E]
   float Drag_Coefficient;    //[I-S]LN=93;[I-E]
   // ================================   //[I-S]LN=94;[I-E]
   // Constantes / Globals   //[I-S]LN=95;[I-E]
   // ================================   //[I-S]LN=96;[I-E]
   @Order(idx = {40})   //[I-S]LN=97;[I-E]
   public static float timeStep = 0.016f;   //[I-S]LN=98;[I-E]
      //[I-S]LN=99;[I-E]
   @Order(idx = {41})   //[I-S]LN=100;[I-E]
   public float Gravity = -9.8f;   //[I-S]LN=101;[I-E]
      //[I-S]LN=102;[I-E]
   // ================================   //[I-S]LN=103;[I-E]
   // Controle de qualidade / performance   //[I-S]LN=104;[I-E]
   // ================================   //[I-S]LN=105;[I-E]
   @Order(idx = {50})   //[I-S]LN=106;[I-E]
   public int Quality_Level_Max2 = 0; // 0 = baixo, 1 = médio, 2 = alto   //[I-S]LN=107;[I-E]
      //[I-S]LN=108;[I-E]
   @Order(idx = {51})   //[I-S]LN=109;[I-E]
   public boolean Self_Collision;   //[I-S]LN=110;[I-E]
      //[I-S]LN=111;[I-E]
   @Order(idx = {52})   //[I-S]LN=112;[I-E]
   public boolean Advanced_Wind;   //[I-S]LN=113;[I-E]
      //[I-S]LN=114;[I-E]
   @Order(idx = {53})   //[I-S]LN=115;[I-E]
   public boolean Seam_Constraints;   //[I-S]LN=116;[I-E]
      //[I-S]LN=117;[I-E]
   @Order(idx = {54})   //[I-S]LN=118;[I-E]
   public boolean Mesh_Collision;   //[I-S]LN=119;[I-E]
      //[I-S]LN=120;[I-E]
   // ================================   //[I-S]LN=121;[I-E]
   // Estado interno do simulador   //[I-S]LN=122;[I-E]
   // ================================   //[I-S]LN=123;[I-E]
   @Order(idx = {70})   //[I-S]LN=124;[I-E]
   private clothPoint[] points;   //[I-S]LN=125;[I-E]
      //[I-S]LN=126;[I-E]
   @Order(idx = {71})   //[I-S]LN=127;[I-E]
   private List<ClothConstraint> constraints = new ArrayList<ClothConstraint>();   //[I-S]LN=128;[I-E]
      //[I-S]LN=129;[I-E]
   @Order(idx = {72})   //[I-S]LN=130;[I-E]
   private SpatialHash spatialHash;   //[I-S]LN=131;[I-E]
      //[I-S]LN=132;[I-E]
   @Order(idx = {73})   //[I-S]LN=133;[I-E]
   private float cellSize = 0.2f;   //[I-S]LN=134;[I-E]
      //[I-S]LN=135;[I-E]
   @Order(idx = {74})   //[I-S]LN=136;[I-E]
   private Vertex mesh;   //[I-S]LN=137;[I-E]
      //[I-S]LN=138;[I-E]
   @Order(idx = {75})   //[I-S]LN=139;[I-E]
   private NativeFloatBuffer vertexBuffer;   //[I-S]LN=140;[I-E]
      //[I-S]LN=141;[I-E]
   @Order(idx = {76})   //[I-S]LN=142;[I-E]
   private NativeFloatBuffer normalBuffer;   //[I-S]LN=143;[I-E]
      //[I-S]LN=144;[I-E]
   // ================================   //[I-S]LN=145;[I-E]
   // Variáveis temporárias / contadores   //[I-S]LN=146;[I-E]
   // ================================   //[I-S]LN=147;[I-E]
   @Order(idx = {80})   //[I-S]LN=148;[I-E]
   private Vector3 tempVec1 = new Vector3();   //[I-S]LN=149;[I-E]
      //[I-S]LN=150;[I-E]
   @Order(idx = {81})   //[I-S]LN=151;[I-E]
   private int frameCount = 0;   //[I-S]LN=152;[I-E]
      //[I-S]LN=153;[I-E]
   // physics accumulator + damping explícito   //[I-S]LN=154;[I-E]
   private float physAccumulator = 0f;   //[I-S]LN=155;[I-E]
      //[I-S]LN=156;[I-E]
   @Order(idx = {82})   //[I-S]LN=157;[I-E]
   private float windTimeAccumulator = 0;   //[I-S]LN=158;[I-E]
      //[I-S]LN=159;[I-E]
   // temporários para vento (evita muitos new Vector3 por frame)   //[I-S]LN=160;[I-E]
   private Vector3 windTemp = new Vector3();    //[I-S]LN=161;[I-E]
   private Vector3 relVelTemp = new Vector3();    //[I-S]LN=162;[I-E]
      //[I-S]LN=163;[I-E]
   //aplicar mesh apenas quando necessário   //[I-S]LN=164;[I-E]
   private boolean meshDirty = false;    //[I-S]LN=165;[I-E]
      //[I-S]LN=166;[I-E]
   // ================================   //[I-S]LN=167;[I-E]
   // Dados adicionais / grupos / colisores de malha   //[I-S]LN=168;[I-E]
   // ================================   //[I-S]LN=169;[I-E]
   @Order(idx = {90})   //[I-S]LN=170;[I-E]
   private Map<String, List<Integer>> seamGroups;   //[I-S]LN=171;[I-E]
      //[I-S]LN=172;[I-E]
   @Order(idx = {91})   //[I-S]LN=173;[I-E]
   private List<MeshCollider> meshColliders = new ArrayList<MeshCollider>();   //[I-S]LN=174;[I-E]
      //[I-S]LN=175;[I-E]
   // ================================   //[I-S]LN=176;[I-E]
   // Flags de fixação de bordas / atualização de fixos   //[I-S]LN=177;[I-E]
   // ================================   //[I-S]LN=178;[I-E]
   @Order(idx = {100})   //[I-S]LN=179;[I-E]
   public boolean Fix_Left = false;   //[I-S]LN=180;[I-E]
      //[I-S]LN=181;[I-E]
   @Order(idx = {101})   //[I-S]LN=182;[I-E]
   public boolean Fix_Right = false;   //[I-S]LN=183;[I-E]
      //[I-S]LN=184;[I-E]
   @Order(idx = {102})   //[I-S]LN=185;[I-E]
   public boolean Fix_Top = false;   //[I-S]LN=186;[I-E]
      //[I-S]LN=187;[I-E]
   @Order(idx = {103})   //[I-S]LN=188;[I-E]
   public boolean Fix_Bottom = false;   //[I-S]LN=189;[I-E]
      //[I-S]LN=190;[I-E]
   @Order(idx = {104})   //[I-S]LN=191;[I-E]
   public boolean Update_Fixed_Pos;   //[I-S]LN=192;[I-E]
    //[I-S]LN=193;[I-E]
   //==================== //[I-S]LN=194;[I-E]
   @Order(idx = {110}) //[I-S]LN=195;[I-E]
   public int normalsUpdateInterval = 2; // recalcula normais a cada N frames (>=1) //[I-S]LN=196;[I-E]
    //[I-S]LN=197;[I-E]
   @Order(idx = {111}) //[I-S]LN=198;[I-E]
   public boolean forceRecalculateNormals = false; // debug //[I-S]LN=199;[I-E]
    //[I-S]LN=200;[I-E]
   private int framesSinceNormals = 0; //[I-S]LN=201;[I-E]
   //==================== //[I-S]LN=202;[I-E]
    //[I-S]LN=203;[I-E]
   private HashMap<ClothConstraint, Float> constraintRestLengths = new HashMap<ClothConstraint, Float>(); //[I-S]LN=204;[I-E]
    //[I-S]LN=205;[I-E]
   private HashMap<String, List<Integer>> buildEditorSeamGroups() {   //[I-S]LN=206;[I-E]
     HashMap<String, List<Integer>> groups = new HashMap<String, List<Integer>>();   //[I-S]LN=207;[I-E]
     float threshold = 0.0001f; // tolerância para considerar mesma posição   //[I-S]LN=208;[I-E]
      //[I-S]LN=209;[I-E]
     int childCount = myObject.getChildCount();   //[I-S]LN=210;[I-E]
     for (int i = 0; i < childCount; i++) {   //[I-S]LN=211;[I-E]
       SpatialObject pointObj = myObject.findChildObject("ponto-" + i);   //[I-S]LN=212;[I-E]
       if (pointObj == null) continue;   //[I-S]LN=213;[I-E]
      //[I-S]LN=214;[I-E]
       Vector3 pos = pointObj.getPosition();   //[I-S]LN=215;[I-E]
       // Arredonda a posição para uma "chave" para agrupar   //[I-S]LN=216;[I-E]
       float x = Math.round(pos.getX() / threshold) * threshold;   //[I-S]LN=217;[I-E]
       float y = Math.round(pos.getY() / threshold) * threshold;   //[I-S]LN=218;[I-E]
       float z = Math.round(pos.getZ() / threshold) * threshold;   //[I-S]LN=219;[I-E]
      //[I-S]LN=220;[I-E]
       String key = String.format("%.6f_%.6f_%.6f", x, y, z);   //[I-S]LN=221;[I-E]
      //[I-S]LN=222;[I-E]
       if (!groups.containsKey(key)) {   //[I-S]LN=223;[I-E]
         groups.put(key, new ArrayList<Integer>());   //[I-S]LN=224;[I-E]
       }   //[I-S]LN=225;[I-E]
       groups.get(key).add(i);   //[I-S]LN=226;[I-E]
     }   //[I-S]LN=227;[I-E]
     return groups;   //[I-S]LN=228;[I-E]
   }   //[I-S]LN=229;[I-E]
    //[I-S]LN=230;[I-E]
     private void sanitizeTempVerts(float[] verts, NativeFloatBuffer prevBuffer) { //[I-S]LN=231;[I-E]
     if (verts == null) return; //[I-S]LN=232;[I-E]
     int len = verts.length; //[I-S]LN=233;[I-E]
     for (int i = 0; i < len; i++) { //[I-S]LN=234;[I-E]
       float v = verts[i]; //[I-S]LN=235;[I-E]
       if (Float.isNaN(v) || Float.isInfinite(v)) { //[I-S]LN=236;[I-E]
         float fallback = 0f; //[I-S]LN=237;[I-E]
         if (prevBuffer != null && i < prevBuffer.capacity()) fallback = prevBuffer.get(i); //[I-S]LN=238;[I-E]
         verts[i] = fallback; //[I-S]LN=239;[I-E]
      } //[I-S]LN=240;[I-E]
     } //[I-S]LN=241;[I-E]
   } //[I-S]LN=242;[I-E]
   private void updateEditorPointRenderersOptimized() {   //[I-S]LN=243;[I-E]
     HashMap<String, List<Integer>> editorGroups = buildEditorSeamGroups();   //[I-S]LN=244;[I-E]
      //[I-S]LN=245;[I-E]
     for (List<Integer> group : editorGroups.values()) {   //[I-S]LN=246;[I-E]
       boolean createdOne = false;   //[I-S]LN=247;[I-E]
      //[I-S]LN=248;[I-E]
       for (int idx : group) {   //[I-S]LN=249;[I-E]
         SpatialObject pointObj = myObject.findChildObject("ponto-" + idx);   //[I-S]LN=250;[I-E]
         if (pointObj == null) continue;   //[I-S]LN=251;[I-E]
      //[I-S]LN=252;[I-E]
         ModelRenderer mr = pointObj.findComponent(ModelRenderer.class);   //[I-S]LN=253;[I-E]
      //[I-S]LN=254;[I-E]
         if (Enable_Visible_Points) {   //[I-S]LN=255;[I-E]
           if (!createdOne) {   //[I-S]LN=256;[I-E]
             if (mr == null) {   //[I-S]LN=257;[I-E]
               ModelRenderer newMr = new ModelRenderer();   //[I-S]LN=258;[I-E]
               Material mt = new Material();   //[I-S]LN=259;[I-E]
               Vertex vtx = new Vertex().loadPrimitive(0);   //[I-S]LN=260;[I-E]
      //[I-S]LN=261;[I-E]
               newMr.setVertex(vtx);   //[I-S]LN=262;[I-E]
               newMr.setMaterial(mt);   //[I-S]LN=263;[I-E]
      //[I-S]LN=264;[I-E]
               pointObj.addComponent(newMr);   //[I-S]LN=265;[I-E]
             }   //[I-S]LN=266;[I-E]
             createdOne = true;   //[I-S]LN=267;[I-E]
           } else {   //[I-S]LN=268;[I-E]
             if (mr != null) {   //[I-S]LN=269;[I-E]
               pointObj.removeComponent(mr);   //[I-S]LN=270;[I-E]
             }   //[I-S]LN=271;[I-E]
           }   //[I-S]LN=272;[I-E]
         } else {   //[I-S]LN=273;[I-E]
           if (mr != null) {   //[I-S]LN=274;[I-E]
             pointObj.removeComponent(mr);   //[I-S]LN=275;[I-E]
           }   //[I-S]LN=276;[I-E]
         }   //[I-S]LN=277;[I-E]
       }   //[I-S]LN=278;[I-E]
     }   //[I-S]LN=279;[I-E]
   }   //[I-S]LN=280;[I-E]
      //[I-S]LN=281;[I-E]
      //[I-S]LN=282;[I-E]
   private HashMap<String, List<Integer>> buildWorldSeamGroups() {   //[I-S]LN=283;[I-E]
       HashMap<String, List<Integer>> groups = new HashMap<String, List<Integer>>();   //[I-S]LN=284;[I-E]
       float threshold = 0.0001f; // tolerância pra agrupar posições próximas   //[I-S]LN=285;[I-E]
      //[I-S]LN=286;[I-E]
       for (int i = 0; i < points.length; i++) {   //[I-S]LN=287;[I-E]
           Vector3 worldPos = points[i].position; // posição mundial do ponto   //[I-S]LN=288;[I-E]
           // Arredonda cada componente para a tolerância definida   //[I-S]LN=289;[I-E]
           float x = Math.round(worldPos.getX() / threshold) * threshold;   //[I-S]LN=290;[I-E]
           float y = Math.round(worldPos.getY() / threshold) * threshold;   //[I-S]LN=291;[I-E]
           float z = Math.round(worldPos.getZ() / threshold) * threshold;   //[I-S]LN=292;[I-E]
      //[I-S]LN=293;[I-E]
           String key = String.format("%.6f_%.6f_%.6f", x, y, z);   //[I-S]LN=294;[I-E]
      //[I-S]LN=295;[I-E]
           if (!groups.containsKey(key)) {   //[I-S]LN=296;[I-E]
               groups.put(key, new ArrayList<Integer>());   //[I-S]LN=297;[I-E]
           }   //[I-S]LN=298;[I-E]
           groups.get(key).add(i);   //[I-S]LN=299;[I-E]
       }   //[I-S]LN=300;[I-E]
      //[I-S]LN=301;[I-E]
       return groups;   //[I-S]LN=302;[I-E]
   }   //[I-S]LN=303;[I-E]
   private void propagateFixedPointsInGroups() {   //[I-S]LN=304;[I-E]
       for (List<Integer> group : seamGroups.values()) {   //[I-S]LN=305;[I-E]
           boolean anyFixed = false;   //[I-S]LN=306;[I-E]
           for (int idx : group) {   //[I-S]LN=307;[I-E]
               if (points[idx].isFixed) {   //[I-S]LN=308;[I-E]
                   anyFixed = true;   //[I-S]LN=309;[I-E]
                   break;   //[I-S]LN=310;[I-E]
               }   //[I-S]LN=311;[I-E]
           }   //[I-S]LN=312;[I-E]
           if (anyFixed) {   //[I-S]LN=313;[I-E]
               for (int idx : group) {   //[I-S]LN=314;[I-E]
                   points[idx].isFixed = true;   //[I-S]LN=315;[I-E]
               }   //[I-S]LN=316;[I-E]
           }   //[I-S]LN=317;[I-E]
       }   //[I-S]LN=318;[I-E]
   }   //[I-S]LN=319;[I-E]
      //[I-S]LN=320;[I-E]
   private void doResetPositionsFromOriginalMesh() {   //[I-S]LN=321;[I-E]
     ModelRenderer mr = myObject.findComponent(ModelRenderer.class);   //[I-S]LN=322;[I-E]
     if (mr != null) {   //[I-S]LN=323;[I-E]
       Vertex mesh = mr.getVertex();   //[I-S]LN=324;[I-E]
       NativeFloatBuffer originalVertexBuf = mesh.getVerticesBuffer();   //[I-S]LN=325;[I-E]
       int totalFloats = originalVertexBuf.capacity();   //[I-S]LN=326;[I-E]
       int vertexCount = totalFloats / 3;   //[I-S]LN=327;[I-E]
      //[I-S]LN=328;[I-E]
       for (int i = 0; i < vertexCount; i++) {   //[I-S]LN=329;[I-E]
         int idx = i * 3;   //[I-S]LN=330;[I-E]
         Vector3 originalLocalPos = new Vector3(originalVertexBuf.get(idx), originalVertexBuf.get(idx + 1), originalVertexBuf.get(idx + 2));   //[I-S]LN=331;[I-E]
         Vector3 worldPos = myObject.getTransform().transformPoint(originalLocalPos);   //[I-S]LN=332;[I-E]
      //[I-S]LN=333;[I-E]
         SpatialObject pointObj = myObject.findChildObject("ponto-" + i);   //[I-S]LN=334;[I-E]
         if (pointObj != null) {   //[I-S]LN=335;[I-E]
           pointObj.setPosition(myObject.getTransform().inverseTransformPoint(worldPos));   //[I-S]LN=336;[I-E]
         }   //[I-S]LN=337;[I-E]
      //[I-S]LN=338;[I-E]
         if (points != null && i < points.length && points[i] != null) {   //[I-S]LN=339;[I-E]
           points[i].position = worldPos.copy();   //[I-S]LN=340;[I-E]
           points[i].previousPosition = worldPos.copy();   //[I-S]LN=341;[I-E]
           points[i].localPosition = originalLocalPos;   //[I-S]LN=342;[I-E]
         }   //[I-S]LN=343;[I-E]
       }   //[I-S]LN=344;[I-E]
      //[I-S]LN=345;[I-E]
       Update_Mesh = false; // Força atualizar mesh com as novas posições   //[I-S]LN=346;[I-E]
     }   //[I-S]LN=347;[I-E]
     Reset_Points_Positions = false;   //[I-S]LN=348;[I-E]
   }   //[I-S]LN=349;[I-E]
      //[I-S]LN=350;[I-E]
      //[I-S]LN=351;[I-E]
      //[I-S]LN=352;[I-E]
   // mexer no editor   //[I-S]LN=353;[I-E]
   public void stoppedRepeat() {   //[I-S]LN=354;[I-E]
     if (Enable_Visible_Points != lastEVisiblePoints) {   //[I-S]LN=355;[I-E]
       updateEditorPointRenderersOptimized();   //[I-S]LN=356;[I-E]
       lastEVisiblePoints = Enable_Visible_Points;   //[I-S]LN=357;[I-E]
     }   //[I-S]LN=358;[I-E]
      //[I-S]LN=359;[I-E]
     if (Reset_Points_Positions) {   //[I-S]LN=360;[I-E]
       doResetPositionsFromOriginalMesh();    //[I-S]LN=361;[I-E]
     }   //[I-S]LN=362;[I-E]
      //[I-S]LN=363;[I-E]
     if (myObject.getChildCount() > 0) {   //[I-S]LN=364;[I-E]
       SpatialObject obj = myObject.findChildObject("ponto-" + 0);   //[I-S]LN=365;[I-E]
       if (obj != null) Editor_Mode = true;   //[I-S]LN=366;[I-E]
       atualizado = 1;   //[I-S]LN=367;[I-E]
     }   //[I-S]LN=368;[I-E]
      //[I-S]LN=369;[I-E]
     if (Editor_Mode) {   //[I-S]LN=370;[I-E]
       // === INICIALIZAÇÃO ===   //[I-S]LN=371;[I-E]
       if (atualizado == 0) {   //[I-S]LN=372;[I-E]
         ModelRenderer mr = myObject.findComponent(ModelRenderer.class);   //[I-S]LN=373;[I-E]
         mesh = mr.getVertex();   //[I-S]LN=374;[I-E]
         NativeFloatBuffer originalVertexBuf = mesh.getVerticesBuffer();   //[I-S]LN=375;[I-E]
         int totalFloats = originalVertexBuf.capacity();   //[I-S]LN=376;[I-E]
         int vertexCount = totalFloats / 3;   //[I-S]LN=377;[I-E]
      //[I-S]LN=378;[I-E]
         vertexBuffer = new NativeFloatBuffer(totalFloats, NativeFloatBuffer.Precision.FLOAT16);   //[I-S]LN=379;[I-E]
         for (int i = 0; i < totalFloats; i++) {   //[I-S]LN=380;[I-E]
           vertexBuffer.put(originalVertexBuf.get(i));   //[I-S]LN=381;[I-E]
         }   //[I-S]LN=382;[I-E]
         mesh.setVertices(vertexBuffer); // opcional   //[I-S]LN=383;[I-E]
      //[I-S]LN=384;[I-E]
         points = new clothPoint[vertexCount];   //[I-S]LN=385;[I-E]
      //[I-S]LN=386;[I-E]
         for (int i = 0; i < vertexCount; i++) {   //[I-S]LN=387;[I-E]
           int b = i * 3;   //[I-S]LN=388;[I-E]
           Vector3 local = new Vector3(vertexBuffer.get(b), vertexBuffer.get(b + 1), vertexBuffer.get(b + 2));   //[I-S]LN=389;[I-E]
           Vector3 world = myObject.getTransform().transformPoint(local);   //[I-S]LN=390;[I-E]
      //[I-S]LN=391;[I-E]
           SpatialObject pobj = new SpatialObject("ponto-" + i);   //[I-S]LN=392;[I-E]
      //[I-S]LN=393;[I-E]
           clothPoint p = new clothPoint();   //[I-S]LN=394;[I-E]
           pobj.addComponent(p);   //[I-S]LN=395;[I-E]
           pobj.setGlobalScale(new Vector3(0.05f, 0.05f, 0.05f));   //[I-S]LN=396;[I-E]
          //[I-S]LN=397;[I-E]
           p.position = world;   //[I-S]LN=398;[I-E]
           p.previousPosition = world.copy();   //[I-S]LN=399;[I-E]
           p.localPosition = local;   //[I-S]LN=400;[I-E]
           p.vertexIndex = i;   //[I-S]LN=401;[I-E]
           pobj.setPosition(myObject.getTransform().inverseTransformPoint(p.position));   //[I-S]LN=402;[I-E]
           pobj.setParent(myObject);   //[I-S]LN=403;[I-E]
      //[I-S]LN=404;[I-E]
           points[i] = p;   //[I-S]LN=405;[I-E]
         }   //[I-S]LN=406;[I-E]
      //[I-S]LN=407;[I-E]
         atualizado = 1;   //[I-S]LN=408;[I-E]
       }   //[I-S]LN=409;[I-E]
      //[I-S]LN=410;[I-E]
       // === ATUALIZAÇÃO VISUAL ===   //[I-S]LN=411;[I-E]
       if (!Update_Mesh && points != null) {   //[I-S]LN=412;[I-E]
         ModelRenderer mr = myObject.findComponent(ModelRenderer.class);   //[I-S]LN=413;[I-E]
         mesh = mr.getVertex();   //[I-S]LN=414;[I-E]
         NativeFloatBuffer originalVertexBuf = mesh.getVerticesBuffer();   //[I-S]LN=415;[I-E]
         int totalFloats = originalVertexBuf.capacity();   //[I-S]LN=416;[I-E]
         int vertexCount = totalFloats / 3;   //[I-S]LN=417;[I-E]
      //[I-S]LN=418;[I-E]
         if (vertexBuffer == null) {   //[I-S]LN=419;[I-E]
           vertexBuffer = new NativeFloatBuffer(totalFloats, NativeFloatBuffer.Precision.FLOAT16);   //[I-S]LN=420;[I-E]
           for (int i = 0; i < totalFloats; i++) {   //[I-S]LN=421;[I-E]
             vertexBuffer.put(originalVertexBuf.get(i));   //[I-S]LN=422;[I-E]
           }   //[I-S]LN=423;[I-E]
           mesh.setVertices(vertexBuffer);   //[I-S]LN=424;[I-E]
         }   //[I-S]LN=425;[I-E]
      //[I-S]LN=426;[I-E]
         if (tempVerts == null || tempVerts.length != totalFloats) {   //[I-S]LN=427;[I-E]
           tempVerts = new float[totalFloats];   //[I-S]LN=428;[I-E]
         }   //[I-S]LN=429;[I-E]
      //[I-S]LN=430;[I-E]
         for (int i = 0; i < vertexCount; i++) {   //[I-S]LN=431;[I-E]
           SpatialObject pobj = myObject.findChildObject("ponto-" + i);   //[I-S]LN=432;[I-E]
           if (pobj != null) {   //[I-S]LN=433;[I-E]
             clothPoint p = pobj.findComponent(clothPoint.class);   //[I-S]LN=434;[I-E]
             p.position = pobj.getGlobalPosition();   //[I-S]LN=435;[I-E]
             p.previousPosition = pobj.getGlobalPosition();   //[I-S]LN=436;[I-E]
           }   //[I-S]LN=437;[I-E]
         }   //[I-S]LN=438;[I-E]
      //[I-S]LN=439;[I-E]
         for (int i = 0; i < vertexCount; i++) {   //[I-S]LN=440;[I-E]
           Vector3 local = myObject.getTransform().inverseTransformPoint(points[i].position);   //[I-S]LN=441;[I-E]
           int idx = i * 3;   //[I-S]LN=442;[I-E]
           tempVerts[idx] = local.getX();   //[I-S]LN=443;[I-E]
           tempVerts[idx + 1] = local.getY();   //[I-S]LN=444;[I-E]
           tempVerts[idx + 2] = local.getZ();   //[I-S]LN=445;[I-E]
         }   //[I-S]LN=446;[I-E]
      //[I-S]LN=447;[I-E]
         vertexBuffer.set(tempVerts);   //[I-S]LN=448;[I-E]
         meshDirty = true;    //[I-S]LN=449;[I-E]
         Update_Mesh = true;   //[I-S]LN=450;[I-E]
       }   //[I-S]LN=451;[I-E]
     }   //[I-S]LN=452;[I-E]
      //[I-S]LN=453;[I-E]
     if (Editor_Clear_All) {   //[I-S]LN=454;[I-E]
       // === SAÍDA DO MODO EDITOR ===   //[I-S]LN=455;[I-E]
       List<SpatialObject> toDestroy = new ArrayList<SpatialObject>();    //[I-S]LN=456;[I-E]
       for (int i = 0; i < myObject.getChildCount(); i++) {   //[I-S]LN=457;[I-E]
         SpatialObject pobj = myObject.findChildObject("ponto-" + i);   //[I-S]LN=458;[I-E]
         if (pobj != null) toDestroy.add(pobj);   //[I-S]LN=459;[I-E]
       }   //[I-S]LN=460;[I-E]
       for (SpatialObject p : toDestroy) p.destroy();   //[I-S]LN=461;[I-E]
       Editor_Mode = false;   //[I-S]LN=462;[I-E]
       Editor_Clear_All = false;   //[I-S]LN=463;[I-E]
       atualizado = 0;   //[I-S]LN=464;[I-E]
     }   //[I-S]LN=465;[I-E]
      //[I-S]LN=466;[I-E]
     if (meshDirty) {   //[I-S]LN=467;[I-E]
       mesh.recalculateBoundingBox();   //[I-S]LN=468;[I-E]
       mesh.regenerateNormals();   //[I-S]LN=469;[I-E]
       mesh.apply();   //[I-S]LN=470;[I-E]
       meshDirty = false;   //[I-S]LN=471;[I-E]
     }   //[I-S]LN=472;[I-E]
   }   //[I-S]LN=473;[I-E]
      //[I-S]LN=474;[I-E]
   @Override   //[I-S]LN=475;[I-E]
   public void start() {   //[I-S]LN=476;[I-E]
      //[I-S]LN=477;[I-E]
     if (Stiffness > 1) Stiffness = 1;   //[I-S]LN=478;[I-E]
     // carrega mesh e buffers   //[I-S]LN=479;[I-E]
     ModelRenderer mr = myObject.findComponent(ModelRenderer.class);   //[I-S]LN=480;[I-E]
     mesh = mr.getVertex();   //[I-S]LN=481;[I-E]
     NativeFloatBuffer originalVertexBuf = mesh.getVerticesBuffer();   //[I-S]LN=482;[I-E]
     NativeFloatBuffer originalNormalBuf = mesh.getNormalsBuffer();   //[I-S]LN=483;[I-E]
      //[I-S]LN=484;[I-E]
     int totalFloats = originalVertexBuf.capacity(); // ex: 3000 floats = 1000 vértices   //[I-S]LN=485;[I-E]
     int totalNormals = originalNormalBuf.capacity();   //[I-S]LN=486;[I-E]
     int vertexCount = totalFloats / 3;   //[I-S]LN=487;[I-E]
      //[I-S]LN=488;[I-E]
     tempVerts = new float[vertexCount * 3];   //[I-S]LN=489;[I-E]
     vertexBuffer = new NativeFloatBuffer(totalFloats, NativeFloatBuffer.Precision.FLOAT16); // otimizado   //[I-S]LN=490;[I-E]
     normalBuffer = new NativeFloatBuffer(totalNormals, NativeFloatBuffer.Precision.FLOAT16); // otimizado   //[I-S]LN=491;[I-E]
      //[I-S]LN=492;[I-E]
     for (int i = 0; i < totalFloats; i++) {   //[I-S]LN=493;[I-E]
       vertexBuffer.put(originalVertexBuf.get(i));   //[I-S]LN=494;[I-E]
       normalBuffer.put(originalNormalBuf.get(i));   //[I-S]LN=495;[I-E]
     }   //[I-S]LN=496;[I-E]
      //[I-S]LN=497;[I-E]
     mesh.setVertices(vertexBuffer);   //[I-S]LN=498;[I-E]
     mesh.setNormals(normalBuffer);   //[I-S]LN=499;[I-E]
      //[I-S]LN=500;[I-E]
     // cria pontos   //[I-S]LN=501;[I-E]
     points = new clothPoint[vertexCount];   //[I-S]LN=502;[I-E]
     spatialHash = new SpatialHash(cellSize);   //[I-S]LN=503;[I-E]
      //[I-S]LN=504;[I-E]
     float minX = Float.POSITIVE_INFINITY, maxX = Float.NEGATIVE_INFINITY;   //[I-S]LN=505;[I-E]
     float minZ = Float.POSITIVE_INFINITY, maxZ = Float.NEGATIVE_INFINITY;   //[I-S]LN=506;[I-E]
     float threshold = 0.001f;   //[I-S]LN=507;[I-E]
      //[I-S]LN=508;[I-E]
     for (int i = 0; i < vertexCount; i++) {   //[I-S]LN=509;[I-E]
       int b = i * 3;   //[I-S]LN=510;[I-E]
       float x = vertexBuffer.get(b);   //[I-S]LN=511;[I-E]
       float z = vertexBuffer.get(b + 2);   //[I-S]LN=512;[I-E]
      //[I-S]LN=513;[I-E]
       if (x < minX) minX = x;   //[I-S]LN=514;[I-E]
       if (x > maxX) maxX = x;   //[I-S]LN=515;[I-E]
       if (z < minZ) minZ = z;   //[I-S]LN=516;[I-E]
       if (z > maxZ) maxZ = z;   //[I-S]LN=517;[I-E]
     }   //[I-S]LN=518;[I-E]
     for (int i = 0; i < vertexCount; i++) {   //[I-S]LN=519;[I-E]
       int b = i * 3;   //[I-S]LN=520;[I-E]
       Vector3 local = new Vector3(vertexBuffer.get(b), vertexBuffer.get(b + 1), vertexBuffer.get(b + 2));   //[I-S]LN=521;[I-E]
       Vector3 world = myObject.getTransform().transformPoint(local);   //[I-S]LN=522;[I-E]
      //[I-S]LN=523;[I-E]
       SpatialObject pobj = myObject.findChildObject("ponto-" + i);   //[I-S]LN=524;[I-E]
       clothPoint p;   //[I-S]LN=525;[I-E]
      //[I-S]LN=526;[I-E]
       if (pobj != null && pobj.findComponent(clothPoint.class) != null) {   //[I-S]LN=527;[I-E]
         // Usa o ponto já existente (pré-moldado no editor)   //[I-S]LN=528;[I-E]
         p = pobj.findComponent(clothPoint.class);   //[I-S]LN=529;[I-E]
         p.position = pobj.getGlobalPosition();   //[I-S]LN=530;[I-E]
         p.previousPosition = pobj.getGlobalPosition();   //[I-S]LN=531;[I-E]
         p.localPosition = myObject.getTransform().inverseTransformPoint(p.position);   //[I-S]LN=532;[I-E]
         p.vertexIndex = i;   //[I-S]LN=533;[I-E]
       } else {   //[I-S]LN=534;[I-E]
         // Cria um ponto novo   //[I-S]LN=535;[I-E]
         p = new clothPoint();   //[I-S]LN=536;[I-E]
         p.position = world;   //[I-S]LN=537;[I-E]
         p.previousPosition = world.copy();   //[I-S]LN=538;[I-E]
         p.localPosition = local;   //[I-S]LN=539;[I-E]
         p.vertexIndex = i;   //[I-S]LN=540;[I-E]
      //[I-S]LN=541;[I-E]
         // Pode aplicar fixação automática, se quiser   //[I-S]LN=542;[I-E]
         boolean fix = false;   //[I-S]LN=543;[I-E]
         if (Fix_Left && Math.abs(local.getX() - minX) < threshold) fix = true;   //[I-S]LN=544;[I-E]
         if (Fix_Right && Math.abs(local.getX() - maxX) < threshold) fix = true;   //[I-S]LN=545;[I-E]
         if (Fix_Top && Math.abs(local.getZ() - maxZ) < threshold) fix = true;   //[I-S]LN=546;[I-E]
         if (Fix_Bottom && Math.abs(local.getZ() - minZ) < threshold) fix = true;   //[I-S]LN=547;[I-E]
         // Depois que todos os pontos têm isFixed definido, propaga a fixação nos grupos seamGroups   //[I-S]LN=548;[I-E]
         p.isFixed = fix;   //[I-S]LN=549;[I-E]
       }   //[I-S]LN=550;[I-E]
      //[I-S]LN=551;[I-E]
       points[i] = p;   //[I-S]LN=552;[I-E]
       p.applyForce(new Vector3(0.01f, 0.01f, 0.01f));   //[I-S]LN=553;[I-E]
      //[I-S]LN=554;[I-E]
     }   //[I-S]LN=555;[I-E]
      //[I-S]LN=556;[I-E]
     // agrupa vértices coincidentes (seams)   //[I-S]LN=557;[I-E]
        seamGroups=buildWorldSeamGroups();   //[I-S]LN=558;[I-E]
         propagateFixedPointsInGroups();   //[I-S]LN=559;[I-E]
      //[I-S]LN=560;[I-E]
     // cria constraints de costura (opcional)   //[I-S]LN=561;[I-E]
     if (Seam_Constraints) {   //[I-S]LN=562;[I-E]
       for (List<Integer> group : seamGroups.values()) {   //[I-S]LN=563;[I-E]
         if (group.size() < 2) continue;   //[I-S]LN=564;[I-E]
         int first = group.get(0);   //[I-S]LN=565;[I-E]
         for (int k = 1; k < group.size(); k++) {   //[I-S]LN=566;[I-E]
           addConstraint(points[first], points[group.get(k)], 0.1f, ClothConstraint.Type.STRUCTURAL);   //[I-S]LN=567;[I-E]
         }   //[I-S]LN=568;[I-E]
       }   //[I-S]LN=569;[I-E]
     }   //[I-S]LN=570;[I-E]
               //[I-S]LN=571;[I-E]
             //[I-S]LN=572;[I-E]
     // cria structural constraints pelos triângulos   //[I-S]LN=573;[I-E]
     NativeIntBuffer triBuf = mesh.getTrianglesBuffer();   //[I-S]LN=574;[I-E]
     Set<String> seenEdges = new HashSet<String>();   //[I-S]LN=575;[I-E]
     for (int ti = 0; ti < triBuf.capacity(); ti += 3) {   //[I-S]LN=576;[I-E]
       int a = triBuf.get(ti);   //[I-S]LN=577;[I-E]
       int b = triBuf.get(ti + 1);   //[I-S]LN=578;[I-E]
       int c = triBuf.get(ti + 2);   //[I-S]LN=579;[I-E]
       addEdgeConstraint(a, b, seenEdges);   //[I-S]LN=580;[I-E]
       addEdgeConstraint(b, c, seenEdges);   //[I-S]LN=581;[I-E]
       addEdgeConstraint(c, a, seenEdges);   //[I-S]LN=582;[I-E]
     }   //[I-S]LN=583;[I-E]
      //[I-S]LN=584;[I-E]
     for (SpatialObject obj : Colliders_Mesh) {   //[I-S]LN=585;[I-E]
       MeshCollider mc = new MeshCollider();   //[I-S]LN=586;[I-E]
       mc.init(obj);   //[I-S]LN=587;[I-E]
       meshColliders.add(mc);   //[I-S]LN=588;[I-E]
     }   //[I-S]LN=589;[I-E]
     // cria bending constraints   //[I-S]LN=590;[I-E]
     createBendingConstraints();   //[I-S]LN=591;[I-E]
      //[I-S]LN=592;[I-E]
     for (int i = 0; i < myObject.getChildCount(); i++) {   //[I-S]LN=593;[I-E]
       ModelRenderer model = myObject.getChildAt(i).findComponent(ModelRenderer.class);   //[I-S]LN=594;[I-E]
      //[I-S]LN=595;[I-E]
       if (model == null) continue;   //[I-S]LN=596;[I-E]
      //[I-S]LN=597;[I-E]
       myObject.getChildAt(i).removeComponent(model);   //[I-S]LN=598;[I-E]
     }   //[I-S]LN=599;[I-E]
      //[I-S]LN=600;[I-E]
     // normais e bounding box iniciais   //[I-S]LN=601;[I-E]
     mesh.regenerateNormals();   //[I-S]LN=602;[I-E]
     mesh.recalculateBoundingBox();   //[I-S]LN=603;[I-E]
     mesh.apply();   //[I-S]LN=604;[I-E]
      //[I-S]LN=605;[I-E]
     // CHANGED: sensible default for dragCoefficient if user didn't set it   //[I-S]LN=606;[I-E]
     if (Drag_Coefficient == 0f) Drag_Coefficient = 1.0f; // CHANGED   //[I-S]LN=607;[I-E]
   }   //[I-S]LN=608;[I-E]
      //[I-S]LN=609;[I-E]
   /////////////   //[I-S]LN=610;[I-E]
      //[I-S]LN=611;[I-E]
   void updateFixedPoints() {   //[I-S]LN=612;[I-E]
     float minX = Float.POSITIVE_INFINITY, maxX = Float.NEGATIVE_INFINITY;   //[I-S]LN=613;[I-E]
     float minZ = Float.POSITIVE_INFINITY, maxZ = Float.NEGATIVE_INFINITY;   //[I-S]LN=614;[I-E]
      //[I-S]LN=615;[I-E]
     for (clothPoint p : points) {   //[I-S]LN=616;[I-E]
       float x = p.localPosition.getX();   //[I-S]LN=617;[I-E]
       float z = p.localPosition.getZ();   //[I-S]LN=618;[I-E]
       if (x < minX) minX = x;   //[I-S]LN=619;[I-E]
       if (x > maxX) maxX = x;   //[I-S]LN=620;[I-E]
       if (z < minZ) minZ = z;   //[I-S]LN=621;[I-E]
       if (z > maxZ) maxZ = z;   //[I-S]LN=622;[I-E]
     }   //[I-S]LN=623;[I-E]
      //[I-S]LN=624;[I-E]
     float threshold = 0.001f;   //[I-S]LN=625;[I-E]
      //[I-S]LN=626;[I-E]
     for (clothPoint p : points) {   //[I-S]LN=627;[I-E]
       boolean fix = false;   //[I-S]LN=628;[I-E]
       if (Fix_Left && Math.abs(p.localPosition.getX() - minX) < threshold) fix = true;   //[I-S]LN=629;[I-E]
       if (Fix_Right && Math.abs(p.localPosition.getX() - maxX) < threshold) fix = true;   //[I-S]LN=630;[I-E]
       if (Fix_Top && Math.abs(p.localPosition.getZ() - maxZ) < threshold) fix = true;   //[I-S]LN=631;[I-E]
       if (Fix_Bottom && Math.abs(p.localPosition.getZ() - minZ) < threshold) fix = true;   //[I-S]LN=632;[I-E]
       p.isFixed = fix;   //[I-S]LN=633;[I-E]
     }   //[I-S]LN=634;[I-E]
   }   //[I-S]LN=635;[I-E]
      //[I-S]LN=636;[I-E]
   ///////////   //[I-S]LN=637;[I-E]
      //[I-S]LN=638;[I-E]
   @Override //[I-S]LN=639;[I-E]
   public void repeat() { //[I-S]LN=640;[I-E]
     if (Update_Fixed_Pos) { //[I-S]LN=641;[I-E]
       updateFixedPoints(); //[I-S]LN=642;[I-E]
       Update_Fixed_Pos = false; //[I-S]LN=643;[I-E]
     } //[I-S]LN=644;[I-E]
    //[I-S]LN=645;[I-E]
     frameCount++; //[I-S]LN=646;[I-E]
     float dt = Time.deltaTime(); //[I-S]LN=647;[I-E]
     windTimeAccumulator += dt; //[I-S]LN=648;[I-E]
    //[I-S]LN=649;[I-E]
     // accumulate time and run fixed physics steps //[I-S]LN=650;[I-E]
     physAccumulator += dt; //[I-S]LN=651;[I-E]
     float fixedStep = timeStep; // 0.016f por padrão //[I-S]LN=652;[I-E]
     int maxStepsPerFrame = 5; // limita para evitar stall //[I-S]LN=653;[I-E]
    //[I-S]LN=654;[I-E]
     int steps = 0; //[I-S]LN=655;[I-E]
     while (physAccumulator >= fixedStep && steps < maxStepsPerFrame) { //[I-S]LN=656;[I-E]
       // physics sub-step start //[I-S]LN=657;[I-E]
       spatialHash.clear(); //[I-S]LN=658;[I-E]
       for (clothPoint p : points) spatialHash.insert(p, p.position); //[I-S]LN=659;[I-E]
    //[I-S]LN=660;[I-E]
       if (!Do_Not_Use_Phys) { //[I-S]LN=661;[I-E]
         Vector3 gravityForce = new Vector3(0, Gravity, 0); //[I-S]LN=662;[I-E]
    //[I-S]LN=663;[I-E]
         // apply forces //[I-S]LN=664;[I-E]
         for (clothPoint p : points) { //[I-S]LN=665;[I-E]
           if (p.isFixed || p.anchored) continue; //[I-S]LN=666;[I-E]
           p.applyForce(gravityForce); //[I-S]LN=667;[I-E]
           if (Advanced_Wind) applyWind(p); //[I-S]LN=668;[I-E]
         } //[I-S]LN=669;[I-E]
    //[I-S]LN=670;[I-E]
         // integração Verlet — use velocityDamping explícito //[I-S]LN=671;[I-E]
         float damping = Velocity_Damping; //[I-S]LN=672;[I-E]
         for (clothPoint p : points) p.simulate(fixedStep, damping); //[I-S]LN=673;[I-E]
       } //[I-S]LN=674;[I-E]
    //[I-S]LN=675;[I-E]
       // constraint iterations //[I-S]LN=676;[I-E]
       if (Quality_Level_Max2 > 2) Quality_Level_Max2 = 2; //[I-S]LN=677;[I-E]
    //[I-S]LN=678;[I-E]
       int iter = (Quality_Level_Max2 == 2 ? 20 : Quality_Level_Max2 == 1 ? 5 : 3); //[I-S]LN=679;[I-E]
       for (int k = 0; k < iter; k++) { //[I-S]LN=680;[I-E]
         for (ClothConstraint c : constraints) c.satisfy(); //[I-S]LN=681;[I-E]
         if (Self_Collision && Quality_Level_Max2 > 0) solveSelfCollision(); //[I-S]LN=682;[I-E]
       } //[I-S]LN=683;[I-E]
       //[I-S]LN=684;[I-E]
     //[I-S]LN=685;[I-E]
    //[I-S]LN=686;[I-E]
       // colisões //[I-S]LN=687;[I-E]
       if (Colliders_Box.size() > 0) collideWithBoxes(); //[I-S]LN=688;[I-E]
       if (Colliders_Sphere.size() > 0) collideWithSpheres(); //[I-S]LN=689;[I-E]
       if (Mesh_Collision && Colliders_Mesh.size() > 0) collideWithMeshVertices(); //[I-S]LN=690;[I-E]
    //[I-S]LN=691;[I-E]
       // welded seams (note: pode amortecer movimento) //[I-S]LN=692;[I-E]
       // agora ignoramos grupos que contém vértices rasgados (para manter tear visível) //[I-S]LN=693;[I-E]
       for (List<Integer> group : seamGroups.values()) { //[I-S]LN=694;[I-E]
         if (group.size() < 2) continue; //[I-S]LN=695;[I-E]
    //[I-S]LN=696;[I-E]
         Vector3 avgPos = new Vector3(0, 0, 0); //[I-S]LN=697;[I-E]
         Vector3 avgPrev = new Vector3(0, 0, 0); //[I-S]LN=698;[I-E]
         for (int idx : group) { //[I-S]LN=699;[I-E]
           avgPos = avgPos.sum(points[idx].position); //[I-S]LN=700;[I-E]
           avgPrev = avgPrev.sum(points[idx].previousPosition); //[I-S]LN=701;[I-E]
         } //[I-S]LN=702;[I-E]
         avgPos = avgPos.mul(1.0f / group.size()); //[I-S]LN=703;[I-E]
         avgPrev = avgPrev.mul(1.0f / group.size()); //[I-S]LN=704;[I-E]
         for (int idx : group) { //[I-S]LN=705;[I-E]
           points[idx].position = avgPos.copy(); //[I-S]LN=706;[I-E]
           points[idx].previousPosition = avgPrev.copy(); //[I-S]LN=707;[I-E]
         } //[I-S]LN=708;[I-E]
       } //[I-S]LN=709;[I-E]
    //[I-S]LN=710;[I-E]
       updateVertexBuffer(); //[I-S]LN=711;[I-E]
    //[I-S]LN=712;[I-E]
       physAccumulator -= fixedStep; //[I-S]LN=713;[I-E]
       steps++; //[I-S]LN=714;[I-E]
       // physics sub-step end //[I-S]LN=715;[I-E]
     } //[I-S]LN=716;[I-E]
    //[I-S]LN=717;[I-E]
     // safety: prevent huge backlog //[I-S]LN=718;[I-E]
     if (physAccumulator > 0.25f) physAccumulator = 0.25f; //[I-S]LN=719;[I-E]
    //[I-S]LN=720;[I-E]
     // --- apply mesh if dirty (runtime-safe, once per frame) --- //[I-S]LN=721;[I-E]
     if (meshDirty) { //[I-S]LN=722;[I-E]
       framesSinceNormals++; //[I-S]LN=723;[I-E]
    //[I-S]LN=724;[I-E]
       boolean shouldRecalcNormals = forceRecalculateNormals || (framesSinceNormals >= Math.max(1, normalsUpdateInterval)); //[I-S]LN=725;[I-E]
    //[I-S]LN=726;[I-E]
       // Antes de recalcular normais, cheque se o normalBuffer/vertexBuffer tem dados válidos (opcional) //[I-S]LN=727;[I-E]
       // sanitize normalBuffer if needed (similar approach). //[I-S]LN=728;[I-E]
    //[I-S]LN=729;[I-E]
       if (shouldRecalcNormals) { //[I-S]LN=730;[I-E]
         // evita chamadas desnecessárias que podem causar flicker em PBR/shadows //[I-S]LN=731;[I-E]
         mesh.regenerateNormals(); //[I-S]LN=732;[I-E]
         framesSinceNormals = 0; //[I-S]LN=733;[I-E]
       } //[I-S]LN=734;[I-E]
    //[I-S]LN=735;[I-E]
       // recalcula bounding box sempre antes do apply (importante para shadow/occlusion) //[I-S]LN=736;[I-E]
       mesh.recalculateBoundingBox(); //[I-S]LN=737;[I-E]
    //[I-S]LN=738;[I-E]
       // apply atualiza GPU / render thread; faça isso só aqui, em um ponto estável //[I-S]LN=739;[I-E]
       mesh.apply(); //[I-S]LN=740;[I-E]
    //[I-S]LN=741;[I-E]
       meshDirty = false; //[I-S]LN=742;[I-E]
     } //[I-S]LN=743;[I-E]
    //[I-S]LN=744;[I-E]
     // tempo real de vento (fora dos substeps já ok) //[I-S]LN=745;[I-E]
   } //[I-S]LN=746;[I-E]
   ////////////     //[I-S]LN=747;[I-E]
   void createBendingConstraints() {   //[I-S]LN=748;[I-E]
     NativeIntBuffer triBuf = mesh.getTrianglesBuffer();   //[I-S]LN=749;[I-E]
     Map<String, int[]> edgeToTriangles = new HashMap<String, int[]>();   //[I-S]LN=750;[I-E]
      //[I-S]LN=751;[I-E]
     // Mapeia cada aresta aos triângulos que a contêm   //[I-S]LN=752;[I-E]
     for (int ti = 0; ti < triBuf.capacity(); ti += 3) {   //[I-S]LN=753;[I-E]
       int[] tri = {triBuf.get(ti), triBuf.get(ti + 1), triBuf.get(ti + 2)};   //[I-S]LN=754;[I-E]
       for (int i = 0; i < 3; i++) {   //[I-S]LN=755;[I-E]
         int a = tri[i];   //[I-S]LN=756;[I-E]
         int b = tri[(i + 1) % 3];   //[I-S]LN=757;[I-E]
         int min = Math.min(a, b);   //[I-S]LN=758;[I-E]
         int max = Math.max(a, b);   //[I-S]LN=759;[I-E]
         String key = min + "_" + max;   //[I-S]LN=760;[I-E]
      //[I-S]LN=761;[I-E]
         if (!edgeToTriangles.containsKey(key)) {   //[I-S]LN=762;[I-E]
           edgeToTriangles.put(key, new int[] {ti});   //[I-S]LN=763;[I-E]
         } else {   //[I-S]LN=764;[I-E]
           int[] prev = edgeToTriangles.get(key);   //[I-S]LN=765;[I-E]
           edgeToTriangles.put(key, new int[] {prev[0], ti});   //[I-S]LN=766;[I-E]
         }   //[I-S]LN=767;[I-E]
       }   //[I-S]LN=768;[I-E]
     }   //[I-S]LN=769;[I-E]
      //[I-S]LN=770;[I-E]
      //[I-S]LN=771;[I-E]
      //[I-S]LN=772;[I-E]
      //[I-S]LN=773;[I-E]
        //[I-S]LN=774;[I-E]
    //[I-S]LN=775;[I-E]
    //[I-S]LN=776;[I-E]
    //[I-S]LN=777;[I-E]
     // Para cada aresta compartilhada por dois triângulos, cria uma bending constraint   //[I-S]LN=778;[I-E]
     for (Map.Entry<String, int[]> entry : edgeToTriangles.entrySet()) {   //[I-S]LN=779;[I-E]
       int[] tris = entry.getValue();   //[I-S]LN=780;[I-E]
       if (tris.length == 2) {   //[I-S]LN=781;[I-E]
         int t1 = tris[0];   //[I-S]LN=782;[I-E]
         int t2 = tris[1];   //[I-S]LN=783;[I-E]
      //[I-S]LN=784;[I-E]
         int[] tri1 = {triBuf.get(t1), triBuf.get(t1 + 1), triBuf.get(t1 + 2)};   //[I-S]LN=785;[I-E]
         int[] tri2 = {triBuf.get(t2), triBuf.get(t2 + 1), triBuf.get(t2 + 2)};   //[I-S]LN=786;[I-E]
      //[I-S]LN=787;[I-E]
         // Encontra vértices opostos (que não estão na aresta compartilhada)   //[I-S]LN=788;[I-E]
         int[] shared = getSharedEdge(tri1, tri2);   //[I-S]LN=789;[I-E]
         if (shared != null) {   //[I-S]LN=790;[I-E]
           int opp1 = getOppositeVertex(tri1, shared[0], shared[1]);   //[I-S]LN=791;[I-E]
           int opp2 = getOppositeVertex(tri2, shared[0], shared[1]);   //[I-S]LN=792;[I-E]
      //[I-S]LN=793;[I-E]
           if (opp1 != -1 && opp2 != -1) {   //[I-S]LN=794;[I-E]
             addConstraint(   //[I-S]LN=795;[I-E]
                 points[opp1],   //[I-S]LN=796;[I-E]
                 points[opp2],   //[I-S]LN=797;[I-E]
                 Bending_Constraints_Stiff, // stiffness da dobra (ajustável)   //[I-S]LN=798;[I-E]
                 ClothConstraint.Type.BENDING);   //[I-S]LN=799;[I-E]
           }   //[I-S]LN=800;[I-E]
         }   //[I-S]LN=801;[I-E]
       }   //[I-S]LN=802;[I-E]
     }   //[I-S]LN=803;[I-E]
   }   //[I-S]LN=804;[I-E]
      //[I-S]LN=805;[I-E]
   ///////////   //[I-S]LN=806;[I-E]
      //[I-S]LN=807;[I-E]
   // Encontra a aresta compartilhada entre dois triângulos   //[I-S]LN=808;[I-E]
   private int[] getSharedEdge(int[] tri1, int[] tri2) {   //[I-S]LN=809;[I-E]
     int sharedCount = 0;   //[I-S]LN=810;[I-E]
     int[] shared = new int[2];   //[I-S]LN=811;[I-E]
      //[I-S]LN=812;[I-E]
     for (int v1 : tri1) {   //[I-S]LN=813;[I-E]
       for (int v2 : tri2) {   //[I-S]LN=814;[I-E]
         if (v1 == v2) {   //[I-S]LN=815;[I-E]
           if (sharedCount < 2) {   //[I-S]LN=816;[I-E]
             shared[sharedCount++] = v1;   //[I-S]LN=817;[I-E]
           }   //[I-S]LN=818;[I-E]
         }   //[I-S]LN=819;[I-E]
       }   //[I-S]LN=820;[I-E]
     }   //[I-S]LN=821;[I-E]
     return (sharedCount == 2) ? shared : null;   //[I-S]LN=822;[I-E]
   }   //[I-S]LN=823;[I-E]
      //[I-S]LN=824;[I-E]
   /////////   //[I-S]LN=825;[I-E]
      //[I-S]LN=826;[I-E]
   // Retorna o vértice do triângulo que não está na aresta compartilhada   //[I-S]LN=827;[I-E]
   private int getOppositeVertex(int[] tri, int e1, int e2) {   //[I-S]LN=828;[I-E]
     for (int v : tri) {   //[I-S]LN=829;[I-E]
       if (v != e1 && v != e2) {   //[I-S]LN=830;[I-E]
         return v;   //[I-S]LN=831;[I-E]
       }   //[I-S]LN=832;[I-E]
     }   //[I-S]LN=833;[I-E]
     return -1;   //[I-S]LN=834;[I-E]
   }   //[I-S]LN=835;[I-E]
      //[I-S]LN=836;[I-E]
   //////////   //[I-S]LN=837;[I-E]
      //[I-S]LN=838;[I-E]
   private void addEdgeConstraint(int i1, int i2, Set<String> seen) {   //[I-S]LN=839;[I-E]
     int min = Math.min(i1, i2), max = Math.max(i1, i2);   //[I-S]LN=840;[I-E]
     String key = min + "_" + max;   //[I-S]LN=841;[I-E]
     if (!seen.contains(key)) {   //[I-S]LN=842;[I-E]
       seen.add(key);   //[I-S]LN=843;[I-E]
       addConstraint(points[min], points[max], Edge_Constraints_Stiff, ClothConstraint.Type.STRUCTURAL);   //[I-S]LN=844;[I-E]
     }   //[I-S]LN=845;[I-E]
   }   //[I-S]LN=846;[I-E]
      //[I-S]LN=847;[I-E]
   //////////   //[I-S]LN=848;[I-E]
      //[I-S]LN=849;[I-E]
   private void addConstraint(clothPoint p1, clothPoint p2, float stiffness, ClothConstraint.Type type) {   //[I-S]LN=850;[I-E]
     ClothConstraint c = new ClothConstraint();   //[I-S]LN=851;[I-E]
     c.p1 = p1;   //[I-S]LN=852;[I-E]
     c.p2 = p2;   //[I-S]LN=853;[I-E]
     c.stiffness = stiffness;   //[I-S]LN=854;[I-E]
     c.type = type;   //[I-S]LN=855;[I-E]
     c.start();   //[I-S]LN=856;[I-E]
   constraints.add(c); //[I-S]LN=857;[I-E]
   constraintRestLengths.put(c, c.p1.position.distance(c.p2.position)); //[I-S]LN=858;[I-E]
   }   //[I-S]LN=859;[I-E]
      //[I-S]LN=860;[I-E]
   ////////////   //[I-S]LN=861;[I-E]
      //[I-S]LN=862;[I-E]
   private void applyWind(clothPoint p) {   //[I-S]LN=863;[I-E]
     int ni = p.vertexIndex * 3;   //[I-S]LN=864;[I-E]
     tempVec1.set(normalBuffer.get(ni), normalBuffer.get(ni + 1), normalBuffer.get(ni + 2));   //[I-S]LN=865;[I-E]
     tempVec1.normalize();   //[I-S]LN=866;[I-E]
      //[I-S]LN=867;[I-E]
     // ruído e direção variável   //[I-S]LN=868;[I-E]
     float nx = simpleNoise(p.position.getX() * Wind_Noise_Scale, 0, windTimeAccumulator * Wind_Frequency);   //[I-S]LN=869;[I-E]
     float nz = simpleNoise(0, p.position.getZ() * Wind_Noise_Scale, windTimeAccumulator * Wind_Frequency);   //[I-S]LN=870;[I-E]
      //[I-S]LN=871;[I-E]
     // CHANGED: reuse windTemp and relVelTemp to avoid allocations   //[I-S]LN=872;[I-E]
     windTemp.set(Wind_Global_Direction.getX() + nx * Turbulence * 0.3f,   //[I-S]LN=873;[I-E]
                  Wind_Global_Direction.getY() + (nx + nz) * 0.15f * Turbulence,   //[I-S]LN=874;[I-E]
                  Wind_Global_Direction.getZ() + nz * Turbulence * 0.3f);   //[I-S]LN=875;[I-E]
     windTemp.normalize();   //[I-S]LN=876;[I-E]
      //[I-S]LN=877;[I-E]
     float facing = Math.max(0, tempVec1.dot(windTemp));   //[I-S]LN=878;[I-E]
     float pressure = facing * facing * Pressure_Coefficient * Wind_Strength;   //[I-S]LN=879;[I-E]
      //[I-S]LN=880;[I-E]
     relVelTemp.set(p.position.getX() - p.previousPosition.getX(),   //[I-S]LN=881;[I-E]
                    p.position.getY() - p.previousPosition.getY(),   //[I-S]LN=882;[I-E]
                    p.position.getZ() - p.previousPosition.getZ());   //[I-S]LN=883;[I-E]
     relVelTemp.div(Time.deltaTime());   //[I-S]LN=884;[I-E]
      //[I-S]LN=885;[I-E]
     Vector3 windVel = windTemp.mul(Wind_Strength);   //[I-S]LN=886;[I-E]
     float drag = Math.max(0, windVel.sub(relVelTemp).dot(windTemp)) * Drag_Coefficient;   //[I-S]LN=887;[I-E]
      //[I-S]LN=888;[I-E]
     float var = 1.0f + nx * 0.2f;   //[I-S]LN=889;[I-E]
     Vector3 f = windTemp.mul((pressure + drag) * var);   //[I-S]LN=890;[I-E]
     p.applyForce(f);   //[I-S]LN=891;[I-E]
   }   //[I-S]LN=892;[I-E]
      //[I-S]LN=893;[I-E]
   //////////////   //[I-S]LN=894;[I-E]
      //[I-S]LN=895;[I-E]
   private float simpleNoise(float x, float y, float z) {   //[I-S]LN=896;[I-E]
     float v = (float) Math.sin(x * 12.9898f + y * 78.233f + z * 45.164f) * 43758.5453f;   //[I-S]LN=897;[I-E]
     return v - (int) v;   //[I-S]LN=898;[I-E]
   }   //[I-S]LN=899;[I-E]
      //[I-S]LN=900;[I-E]
   ////////////   //[I-S]LN=901;[I-E]
      //[I-S]LN=902;[I-E]
   private void solveSelfCollision() {   //[I-S]LN=903;[I-E]
     float minD = cellSize * 0.5f;   //[I-S]LN=904;[I-E]
     float minDSq = minD * minD;   //[I-S]LN=905;[I-E]
     for (clothPoint p1 : points) {   //[I-S]LN=906;[I-E]
       List<clothPoint> near = spatialHash.query(p1.position, minD);   //[I-S]LN=907;[I-E]
       for (clothPoint p2 : near) {   //[I-S]LN=908;[I-E]
         if (p1 == p2) continue;   //[I-S]LN=909;[I-E]
         Vector3 d = p2.position.sub(p1.position);   //[I-S]LN=910;[I-E]
         float dsq = d.dot(d);   //[I-S]LN=911;[I-E]
         if (dsq > 0 && dsq < minDSq) {   //[I-S]LN=912;[I-E]
           float dist = (float) Math.sqrt(dsq);   //[I-S]LN=913;[I-E]
           float diff = (minD - dist) / dist;   //[I-S]LN=914;[I-E]
           Vector3 corr = d.mul(0.5f * diff);   //[I-S]LN=915;[I-E]
           if (!p1.isFixed && !p1.anchored) p1.position = p1.position.sub(corr);   //[I-S]LN=916;[I-E]
           if (!p2.isFixed && !p1.anchored) p2.position = p2.position.sum(corr);   //[I-S]LN=917;[I-E]
         }   //[I-S]LN=918;[I-E]
       }   //[I-S]LN=919;[I-E]
     }   //[I-S]LN=920;[I-E]
   }   //[I-S]LN=921;[I-E]
      //[I-S]LN=922;[I-E]
   /////////////   //[I-S]LN=923;[I-E]
      //[I-S]LN=924;[I-E]
   private void collideWithBoxes() {   //[I-S]LN=925;[I-E]
     Vector3 center = calculateClothCenter();   //[I-S]LN=926;[I-E]
     for (SpatialObject obj : Colliders_Box) {   //[I-S]LN=927;[I-E]
       Vector3 pos = obj.getTransform().getGlobalPosition();   //[I-S]LN=928;[I-E]
       //  if (center.distance(pos) > 5f) continue;   //[I-S]LN=929;[I-E]
       Vector3 half = obj.getTransform().getGlobalScale().mul(0.52f);   //[I-S]LN=930;[I-E]
       Vector3 min = pos.sub(half), max = pos.sum(half);   //[I-S]LN=931;[I-E]
       for (clothPoint p : points) {   //[I-S]LN=932;[I-E]
         if (p.isFixed) continue;   //[I-S]LN=933;[I-E]
         Vector3 pp = p.position;   //[I-S]LN=934;[I-E]
         boolean inX = pp.getX() >= min.getX() && pp.getX() <= max.getX();   //[I-S]LN=935;[I-E]
         boolean inY = pp.getY() >= min.getY() && pp.getY() <= max.getY();   //[I-S]LN=936;[I-E]
         boolean inZ = pp.getZ() >= min.getZ() && pp.getZ() <= max.getZ();   //[I-S]LN=937;[I-E]
         if (inX && inY && inZ) {   //[I-S]LN=938;[I-E]
           float dxMin = Math.abs(pp.getX() - min.getX()), dxMax = Math.abs(max.getX() - pp.getX());   //[I-S]LN=939;[I-E]
           float dyMin = Math.abs(pp.getY() - min.getY()), dyMax = Math.abs(max.getY() - pp.getY());   //[I-S]LN=940;[I-E]
           float dzMin = Math.abs(pp.getZ() - min.getZ()), dzMax = Math.abs(max.getZ() - pp.getZ());   //[I-S]LN=941;[I-E]
           // empurra pela face mais próxima   //[I-S]LN=942;[I-E]
           float md = dxMin;   //[I-S]LN=943;[I-E]
           Vector3 corr = new Vector3(-dxMin, 0, 0);   //[I-S]LN=944;[I-E]
           if (dxMax < md) {   //[I-S]LN=945;[I-E]
             md = dxMax;   //[I-S]LN=946;[I-E]
             corr.set(dxMax, 0, 0);   //[I-S]LN=947;[I-E]
           }   //[I-S]LN=948;[I-E]
           if (dyMin < md) {   //[I-S]LN=949;[I-E]
             md = dyMin;   //[I-S]LN=950;[I-E]
             corr.set(0, -dyMin, 0);   //[I-S]LN=951;[I-E]
           }   //[I-S]LN=952;[I-E]
           if (dyMax < md) {   //[I-S]LN=953;[I-E]
             md = dyMax;   //[I-S]LN=954;[I-E]
             corr.set(0, dyMax, 0);   //[I-S]LN=955;[I-E]
           }   //[I-S]LN=956;[I-E]
           if (dzMin < md) {   //[I-S]LN=957;[I-E]
             md = dzMin;   //[I-S]LN=958;[I-E]
             corr.set(0, 0, -dzMin);   //[I-S]LN=959;[I-E]
           }   //[I-S]LN=960;[I-E]
           if (dzMax < md) {   //[I-S]LN=961;[I-E]
             md = dzMax;   //[I-S]LN=962;[I-E]
             corr.set(0, 0, dzMax);   //[I-S]LN=963;[I-E]
           }   //[I-S]LN=964;[I-E]
           p.position = p.position.sum(corr);   //[I-S]LN=965;[I-E]
           // damping   //[I-S]LN=966;[I-E]
           Vector3 vel = p.position.sub(p.previousPosition).mul(0.5f);   //[I-S]LN=967;[I-E]
           p.previousPosition = p.position.sub(vel);   //[I-S]LN=968;[I-E]
         }   //[I-S]LN=969;[I-E]
       }   //[I-S]LN=970;[I-E]
     }   //[I-S]LN=971;[I-E]
   }   //[I-S]LN=972;[I-E]
      //[I-S]LN=973;[I-E]
   /////////////   //[I-S]LN=974;[I-E]
     private void collideWithSpheres() { //[I-S]LN=975;[I-E]
     for (SpatialObject obj : Colliders_Sphere) { //[I-S]LN=976;[I-E]
       Vector3 pos = obj.getTransform().getGlobalPosition(); //[I-S]LN=977;[I-E]
       float r = obj.getTransform().getGlobalScale().getX() * 0.53f; //[I-S]LN=978;[I-E]
       float effectiveR = r + pointRadius; //[I-S]LN=979;[I-E]
       float thrSq = effectiveR * effectiveR; //[I-S]LN=980;[I-E]
    //[I-S]LN=981;[I-E]
       for (clothPoint p : points) { //[I-S]LN=982;[I-E]
         if (p.isFixed) continue; //[I-S]LN=983;[I-E]
         Vector3 d = p.position.sub(pos); //[I-S]LN=984;[I-E]
         float distSq = d.dot(d); //[I-S]LN=985;[I-E]
         if (distSq < thrSq && distSq > 1e-8f) { //[I-S]LN=986;[I-E]
           float dist = (float) Math.sqrt(distSq); //[I-S]LN=987;[I-E]
           Vector3 n = d.mul(1.0f / dist); // safe because dist > 1e-8 //[I-S]LN=988;[I-E]
           float penetration = effectiveR - dist; //[I-S]LN=989;[I-E]
           Vector3 corr = n.mul(penetration); //[I-S]LN=990;[I-E]
           p.position = p.position.sum(corr); //[I-S]LN=991;[I-E]
           // damp previousPosition proportional to correction (keeps velocity sane) //[I-S]LN=992;[I-E]
           Vector3 vel = p.position.sub(p.previousPosition).mul(0.5f); //[I-S]LN=993;[I-E]
           p.previousPosition = p.position.sub(vel); //[I-S]LN=994;[I-E]
         } else if (distSq <= 1e-8f) { //[I-S]LN=995;[I-E]
           // caso muito perto/mesmo local: empurra numa direção fixa + random pequena //[I-S]LN=996;[I-E]
           Vector3 corr = new Vector3(0, effectiveR, 0); //[I-S]LN=997;[I-E]
           p.position = p.position.sum(corr); //[I-S]LN=998;[I-E]
           p.previousPosition = p.position.copy(); //[I-S]LN=999;[I-E]
         } //[I-S]LN=1000;[I-E]
       } //[I-S]LN=1001;[I-E]
     } //[I-S]LN=1002;[I-E]
   }  //[I-S]LN=1003;[I-E]
      //[I-S]LN=1004;[I-E]
   //////////////   //[I-S]LN=1005;[I-E]
      //[I-S]LN=1006;[I-E]
   private void collideWithMeshVertices() {   //[I-S]LN=1007;[I-E]
     float threshold = 0.6f; // ajuste fino   //[I-S]LN=1008;[I-E]
     float thrSq = threshold * threshold;   //[I-S]LN=1009;[I-E]
      //[I-S]LN=1010;[I-E]
     for (MeshCollider mc : meshColliders) {   //[I-S]LN=1011;[I-E]
       for (clothPoint p : points) {   //[I-S]LN=1012;[I-E]
         if (p.isFixed) continue;   //[I-S]LN=1013;[I-E]
         for (Vector3 localV : mc.localVerts) {   //[I-S]LN=1014;[I-E]
           // posição do vértice do objeto em world space   //[I-S]LN=1015;[I-E]
           Vector3 wv = mc.transform.transformPoint(localV);   //[I-S]LN=1016;[I-E]
           Vector3 delta = p.position.sub(wv);   //[I-S]LN=1017;[I-E]
           float distSq = delta.dot(delta);   //[I-S]LN=1018;[I-E]
           if (distSq < thrSq && distSq > 0f) {   //[I-S]LN=1019;[I-E]
             float dist = (float) Math.sqrt(distSq);   //[I-S]LN=1020;[I-E]
             float diff = (threshold - dist) / dist;   //[I-S]LN=1021;[I-E]
             Vector3 corr = delta.mul(diff * 0.5f);   //[I-S]LN=1022;[I-E]
             // empurra para fora   //[I-S]LN=1023;[I-E]
             p.position = p.position.sum(corr);   //[I-S]LN=1024;[I-E]
             // damping simples   //[I-S]LN=1025;[I-E]
             Vector3 vel = p.position.sub(p.previousPosition).mul(0.5f);   //[I-S]LN=1026;[I-E]
             p.previousPosition = p.position.sub(vel);   //[I-S]LN=1027;[I-E]
           }   //[I-S]LN=1028;[I-E]
         }   //[I-S]LN=1029;[I-E]
       }   //[I-S]LN=1030;[I-E]
     }   //[I-S]LN=1031;[I-E]
   }   //[I-S]LN=1032;[I-E]
      //[I-S]LN=1033;[I-E]
   /////////////   //[I-S]LN=1034;[I-E]
      //[I-S]LN=1035;[I-E]
   private void updateVertexBuffer() { //[I-S]LN=1036;[I-E]
     for (int i = 0; i < points.length; i++) { //[I-S]LN=1037;[I-E]
       Vector3 local = myObject.getTransform().inverseTransformPoint(points[i].position); //[I-S]LN=1038;[I-E]
       int idx = i * 3; //[I-S]LN=1039;[I-E]
       tempVerts[idx] = local.getX(); //[I-S]LN=1040;[I-E]
       tempVerts[idx + 1] = local.getY(); //[I-S]LN=1041;[I-E]
       tempVerts[idx + 2] = local.getZ(); //[I-S]LN=1042;[I-E]
     } //[I-S]LN=1043;[I-E]
    //[I-S]LN=1044;[I-E]
     // safety: remove NaN/Inf antes de enviar ao GPU //[I-S]LN=1045;[I-E]
     sanitizeTempVerts(tempVerts, vertexBuffer); //[I-S]LN=1046;[I-E]
    //[I-S]LN=1047;[I-E]
     vertexBuffer.set(tempVerts); //[I-S]LN=1048;[I-E]
     meshDirty = true; //[I-S]LN=1049;[I-E]
   }   //[I-S]LN=1050;[I-E]
   private Vector3 calculateClothCenter() {   //[I-S]LN=1051;[I-E]
     Vector3 c = new Vector3();   //[I-S]LN=1052;[I-E]
     for (clothPoint p : points) c = c.sum(p.position);   //[I-S]LN=1053;[I-E]
     return c.div(points.length);   //[I-S]LN=1054;[I-E]
   }   //[I-S]LN=1055;[I-E]
      //[I-S]LN=1056;[I-E]
   ////////////////////   //[I-S]LN=1057;[I-E]
   //pure GPT , idk if this really help that much,but,better than nothing i think   //[I-S]LN=1058;[I-E]
   // SpatialHash otimizado com HashMap   //[I-S]LN=1059;[I-E]
   class SpatialHash {   //[I-S]LN=1060;[I-E]
     private Map<Integer, HashCell> cells = new HashMap<Integer, HashCell>();   //[I-S]LN=1061;[I-E]
     private float cellSize;   //[I-S]LN=1062;[I-E]
      //[I-S]LN=1063;[I-E]
     SpatialHash(float cs) {   //[I-S]LN=1064;[I-E]
       cellSize = cs;   //[I-S]LN=1065;[I-E]
     }   //[I-S]LN=1066;[I-E]
      //[I-S]LN=1067;[I-E]
     void clear() {   //[I-S]LN=1068;[I-E]
       cells.clear();   //[I-S]LN=1069;[I-E]
     }   //[I-S]LN=1070;[I-E]
      //[I-S]LN=1071;[I-E]
     void insert(clothPoint p, Vector3 pos) {   //[I-S]LN=1072;[I-E]
       int x = (int) (pos.getX() / cellSize);   //[I-S]LN=1073;[I-E]
       int y = (int) (pos.getY() / cellSize);   //[I-S]LN=1074;[I-E]
       int z = (int) (pos.getZ() / cellSize);   //[I-S]LN=1075;[I-E]
       int h = (x * 92837111) ^ (y * 689287499) ^ (z * 283923481);   //[I-S]LN=1076;[I-E]
      //[I-S]LN=1077;[I-E]
       HashCell cell = cells.get(h);   //[I-S]LN=1078;[I-E]
       if (cell == null) {   //[I-S]LN=1079;[I-E]
         cell = new HashCell();   //[I-S]LN=1080;[I-E]
         cells.put(h, cell);   //[I-S]LN=1081;[I-E]
       }   //[I-S]LN=1082;[I-E]
       cell.points.add(p);   //[I-S]LN=1083;[I-E]
     }   //[I-S]LN=1084;[I-E]
      //[I-S]LN=1085;[I-E]
     List<clothPoint> query(Vector3 pos, float r) {   //[I-S]LN=1086;[I-E]
       List<clothPoint> out = new ArrayList<clothPoint>();   //[I-S]LN=1087;[I-E]
       int minX = (int) ((pos.getX() - r) / cellSize), maxX = (int) ((pos.getX() + r) / cellSize);   //[I-S]LN=1088;[I-E]
       int minY = (int) ((pos.getY() - r) / cellSize), maxY = (int) ((pos.getY() + r) / cellSize);   //[I-S]LN=1089;[I-E]
       int minZ = (int) ((pos.getZ() - r) / cellSize), maxZ = (int) ((pos.getZ() + r) / cellSize);   //[I-S]LN=1090;[I-E]
       for (int x = minX; x <= maxX; x++)   //[I-S]LN=1091;[I-E]
         for (int y = minY; y <= maxY; y++)   //[I-S]LN=1092;[I-E]
           for (int z = minZ; z <= maxZ; z++) {   //[I-S]LN=1093;[I-E]
             int h = (x * 92837111) ^ (y * 689287499) ^ (z * 283923481);   //[I-S]LN=1094;[I-E]
             HashCell cell = cells.get(h);   //[I-S]LN=1095;[I-E]
             if (cell != null) out.addAll(cell.points);   //[I-S]LN=1096;[I-E]
           }   //[I-S]LN=1097;[I-E]
       return out;   //[I-S]LN=1098;[I-E]
     }   //[I-S]LN=1099;[I-E]
   }   //[I-S]LN=1100;[I-E]
      //[I-S]LN=1101;[I-E]
   class HashCell {   //[I-S]LN=1102;[I-E]
     List<clothPoint> points = new ArrayList<clothPoint>();   //[I-S]LN=1103;[I-E]
   }   //[I-S]LN=1104;[I-E]
}