class Planogenerator extends Component {
   public int width = 10; //[I-S]LN=0;[I-E]
   public int height = 10; //[I-S]LN=1;[I-E]
   public float spacing = 0.2f; //[I-S]LN=2;[I-E]
   boolean meshBuilt = true; //[I-S]LN=3;[I-E]
    //[I-S]LN=4;[I-E]
   private ModelRenderer mrsafe; //[I-S]LN=5;[I-E]
    //[I-S]LN=6;[I-E]
   public void stoppedRepeat() { //[I-S]LN=7;[I-E]
       if(mrsafe==null) //[I-S]LN=8;[I-E]
       mrsafe=myObject.findComponent(ModelRenderer.class); //[I-S]LN=9;[I-E]
        //[I-S]LN=10;[I-E]
     if (mrsafe != null) { //[I-S]LN=11;[I-E]
         if(mrsafe.getVertex()==null && mrsafe.getMaterial() !=null) //[I-S]LN=12;[I-E]
         fazer(); //[I-S]LN=13;[I-E]
     }  //[I-S]LN=14;[I-E]
    //[I-S]LN=15;[I-E]
     // === RODA SOMENTE SE USUÁRIO CLICAR === //[I-S]LN=16;[I-E]
     if (meshBuilt) { //[I-S]LN=17;[I-E]
       fazer(); //[I-S]LN=18;[I-E]
       meshBuilt = false; //[I-S]LN=19;[I-E]
     } //[I-S]LN=20;[I-E]
   } //[I-S]LN=21;[I-E]
    //[I-S]LN=22;[I-E]
   public void fazer() { //[I-S]LN=23;[I-E]
     int vertexCount = width * height; //[I-S]LN=24;[I-E]
     int quadCount = (width - 1) * (height - 1); //[I-S]LN=25;[I-E]
     int indexCount = quadCount * 6; //[I-S]LN=26;[I-E]
    //[I-S]LN=27;[I-E]
     NativeFloatBuffer vertexBuffer = new NativeFloatBuffer(vertexCount * 3); //[I-S]LN=28;[I-E]
     NativeIntBuffer triangleBuffer = new NativeIntBuffer(indexCount); //[I-S]LN=29;[I-E]
     NativeFloatBuffer uvBuffer = new NativeFloatBuffer(vertexCount * 2); //[I-S]LN=30;[I-E]
     for (int y = 0; y < height; y++) { //[I-S]LN=31;[I-E]
       for (int x = 0; x < width; x++) { //[I-S]LN=32;[I-E]
         float u = (float) x / (width - 1); //[I-S]LN=33;[I-E]
         float v = (float) y / (height - 1); //[I-S]LN=34;[I-E]
         uvBuffer.put(u); //[I-S]LN=35;[I-E]
         uvBuffer.put(v); //[I-S]LN=36;[I-E]
       } //[I-S]LN=37;[I-E]
     } //[I-S]LN=38;[I-E]
     // Gerar vértices //[I-S]LN=39;[I-E]
     for (int y = 0; y < height; y++) { //[I-S]LN=40;[I-E]
       for (int x = 0; x < width; x++) { //[I-S]LN=41;[I-E]
         float fx = x * spacing; //[I-S]LN=42;[I-E]
         float fy = 0.0f; //[I-S]LN=43;[I-E]
         float fz = y * spacing; //[I-S]LN=44;[I-E]
    //[I-S]LN=45;[I-E]
         vertexBuffer.put(fx); // X //[I-S]LN=46;[I-E]
         vertexBuffer.put(fy); // Y //[I-S]LN=47;[I-E]
         vertexBuffer.put(fz); // Z //[I-S]LN=48;[I-E]
       } //[I-S]LN=49;[I-E]
     } //[I-S]LN=50;[I-E]
    //[I-S]LN=51;[I-E]
     // Gerar triângulos (6 índices por quad) //[I-S]LN=52;[I-E]
     for (int y = 0; y < height - 1; y++) { //[I-S]LN=53;[I-E]
       for (int x = 0; x < width - 1; x++) { //[I-S]LN=54;[I-E]
         int topLeft = y * width + x; //[I-S]LN=55;[I-E]
         int topRight = topLeft + 1; //[I-S]LN=56;[I-E]
         int bottomLeft = topLeft + width; //[I-S]LN=57;[I-E]
         int bottomRight = bottomLeft + 1; //[I-S]LN=58;[I-E]
    //[I-S]LN=59;[I-E]
         // Primeiro triângulo //[I-S]LN=60;[I-E]
         triangleBuffer.put(topLeft); //[I-S]LN=61;[I-E]
         triangleBuffer.put(bottomLeft); //[I-S]LN=62;[I-E]
         triangleBuffer.put(topRight); //[I-S]LN=63;[I-E]
    //[I-S]LN=64;[I-E]
         // Segundo triângulo //[I-S]LN=65;[I-E]
         triangleBuffer.put(topRight); //[I-S]LN=66;[I-E]
         triangleBuffer.put(bottomLeft); //[I-S]LN=67;[I-E]
         triangleBuffer.put(bottomRight); //[I-S]LN=68;[I-E]
       } //[I-S]LN=69;[I-E]
     } //[I-S]LN=70;[I-E]
    //[I-S]LN=71;[I-E]
     // Resetar posição dos buffers antes de aplicar (por segurança) //[I-S]LN=72;[I-E]
     vertexBuffer.position(0); //[I-S]LN=73;[I-E]
     triangleBuffer.position(0); //[I-S]LN=74;[I-E]
    //[I-S]LN=75;[I-E]
     // Aplicar na malha //[I-S]LN=76;[I-E]
     Vertex vertex = new Vertex(); //[I-S]LN=77;[I-E]
     vertex.setVertices(vertexBuffer); //[I-S]LN=78;[I-E]
     vertex.setTriangles(triangleBuffer); //[I-S]LN=79;[I-E]
     vertex.setUVs(uvBuffer); //[I-S]LN=80;[I-E]
     vertex.recalculateBoundingBox(); //[I-S]LN=81;[I-E]
     vertex.apply(); //[I-S]LN=82;[I-E]
    //[I-S]LN=83;[I-E]
     ModelRenderer mr = myObject.findComponent(ModelRenderer.class); //[I-S]LN=84;[I-E]
     Material mt = mr.getMaterial(); //[I-S]LN=85;[I-E]
     mr.setVertex(vertex); //[I-S]LN=86;[I-E]
     mr.setMaterial(mt); //[I-S]LN=87;[I-E]
   } //[I-S]LN=88;[I-E]
}